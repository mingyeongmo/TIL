# sort(fn)

---

arr.sort()는 배열의 요소를 정렬해줍니다. **배열 자체가 변경**됩니다.

메서드를 호출하면 재정렬 된 배열이 반환되는데, 이미 `arr` 자체가 수정되었기 때문에 반환 값은 잘 사용되지 않는 편입니다.

예시 :

> let arr = [ 1, 2, 15 ];
>
> // arr 내부가 재 정렬됩니다.
> arr.sort();
>
> alert( arr ); // 1, 15, 2

엇! 뭔가 이상하네요.

재정렬 후 배열 요소가 `1, 15, 2`가 되었습니다. 기대하던 결과(`1, 2, 15`)와는 다르네요.
왜 이런 결과가 나왔을까요?

**요소는 문자열로 취급되어 재 정렬되기 때문입니다.**

모든 요소는 문자형으로 변환된 이후에 재 정렬됩니다. 앞서 배웠듯이 문자열 비교는 사전편집 순으로 진행되기 때문에 2는 15보다 큰 값으로 취급됩니다(`"2" > "15"`).

기본 정렬 기준 대신 새로운 정렬 기준을 만들려면 `arr.sort()`에 새로운 함수를 넘겨줘야 합니다.

인수로 넘겨주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 합니다.

> function compare(a, b) {
> if (a > b) return 1; // 첫 번째 값이 두 번째 값보다 큰 경우
> if (a == b) return 0; // 두 값이 같은 경우
> if(a < b) return -1; // 첫 번째 값이 두 번째 값보다 작은 경우
> }

이제 배열 요소를 숫자 오름차순 기준으로 정렬해봅시다.

> function compareNumeric(a, b) {
> if (a > b) return 1;
> if (a == b) return 0;
> if(a < b) return -1;
> }
>
> let arr = [ 1, 2, 15 ];
>
> arr.sort(compareNumeric);
>
> alert(arr); // 1, 2, 15

이제 기대했던 대로 요소가 정렬되었습니다.

여기서 잠시 멈춰 위 예시에서 어떤 일이 일어났는지 생각해 봅시다. 사실 `arr`엔 숫자, 문자열, 객체 등이 들어갈 수 있습니다. 알 수 없는 무언가로 구성된 집합이 되는 거죠. 이제 이 비 동질적인 집합을 정렬해야 한다고 가정해봅시다. 무언가를 정렬하려면 기준이 필요하겠죠? 이때 정렬 기준을 정의해주는 함수(ordering function, 정렬 함수) 가 필요합니다. `sort`에 정렬 함수를 인수로 넘겨주지 않으면 이 메서드는 사전편집 순으로 요소를 정렬합니다.

`arr.sort(fn)` 는 포괄적인 정렬 알고리즘을 이용해 구현되어 있습니다. 대게 최적화된 퀵 소트(quicsort)를 사용하는데, `arr.sort(fn)` 는 주어진 함수를 사용해 정렬 기준을 만들고 이 기준에 따라 요소들을 재배열하므로 개발자는 내부 정렬 동작 원리를 알 필요가 없습니다. 우리가 해야 할 일은 정렬 함수 `fn` 을 만들고 이를 인수로 넘겨주는 것뿐입니다.

정렬 과정에서 어떤 요소끼리 비교가 일어났는지 확인하고 싶다면 아래 코드를 활용하시면 됩니다.

> [1, -2, 15, 2, 0, 8].sort(function(a, b) {
> alert( a + " <> " + b );
> return a - b;  
> });

정렬 중에 한 요소가 특정 요소와 여러 번 비교되는 일이 생기곤 하는데 비교 횟수를 최소화 하려다 보면 이런 일이 발생 할 수 있습니다.

## ℹ️ 정렬 함수는 어떤 숫자든 반환할 수 있습니다.

정렬 함수의 반환 값엔 제약이 없습니다. 양수를 반환하는 경우 첫 번째 인수가 두 번째 인수보다 '크다’를 나타내고, 음수를 반환하는 경우 첫 번째 인수가 두 번째 인수보다 '작다’를 나타내기만 하면 됩니다.

이 점을 이용하면 정렬 함수를 더 간결하게 만들 수 있습니다.

```
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr); // 1, 2, 15
```

## ℹ️ 화살표 함수를 사용합시다.

화살표 함수를 사용하면 정렬 함수를 더 깔끔하게 만들 수 있습니다.

```
arr.sort( (a, b) => a - b );
```

화살표 함수를 활용한 코드와 함수 선언문을 사용한 코드는 동일하게 작동합니다.

## ℹ️ 문자열엔 `localeCompare`를 사용하세요.

strings에서 배운 비교 알고리즘이 기억나시나요? 이 알고리즘은 유니코드를 기준으로 글자를 비교합니다.

`Ö` 같은 문자가 있는 언어에도 대응하려면 `str.localeCompare` 메서드를 사용해 문자열을 비교하는게 좋습니다.

독일어로 나타낸 국가가 요소인 배열을 정렬해봅시다.

```
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (제대로 정렬이 되지 않았습니다.)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (제대로 정렬되었네요!)
```
