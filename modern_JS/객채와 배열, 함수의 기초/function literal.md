# 함수 리터럴로 함수 정의하기

---

함수는 함수 리터럴로도 정의할 수 있습니다. 예를 들어 앞에서 예로 들었던 함수 square는 다음과 같이 함수 리터럴로 수정할 수 있습니다.

```
var square = function(x) {return x * x; };
```

이 코드에서는 function(x) {...} 부분이 함수 리터럴입니다.  
**함수 리터럴**은 이름이 없는 함수이므로 **익명 함수** 또는 **무명 함수**라고 부릅니다. 함수 선언문에서는 끝에 세미콜론을 붙일 필요가 없지만 함수 리터럴을 사용할 때는 끝에 반드시 세미콜론을 붙여야 합니다.  
함수 선언문으로 정의한 함수와 함수 리터럴로 정의한 함수의 사용법은 같습니다.  
square(5)라고 작성하면 함수를 실행할 수 있습니다. 이는 함수 리터럴과 함수 선언문이 모두 내부적으로 square변수에 함수 객체의 참조를 저장하기 때문입니다.  
한 가지 차이점이라면 자바스크립트 엔진이 함수 선언문으로 정의한 함수는 끌어올리지만 함수 리터럴로 정의한 함수는 끌어올리지 않는다는 점입니다. 함수 리터럴로 정의한 익명 함수는 변수에 할당한 후에야 비로소 square라는 이름을 갖게 되고, 그 이름으로 호출할 수 있게 됩니다. 이러한 이유 때문에 함수를 정의하지 않은 상태에서 함수를 사용하려고 하면 타입 오류가 발생합니다.

```
console.log(square(3)); // -> TypeError: square is not a function
var square = function(x) {return x * x; };
```

익명 함수에도 이름을 붙일 수 있습니다.

```
var square = function sq(x) { return x * x; };
```

그러나 코드에서 sq라는 이름은 함수 안에서만 유효하므로 함수 바깥에서는 sq라는 이름으로 함수를 호출할 수 없습니다.  
익명 함수 코드는 디버거에 모두 anonymous function이라고 표시되므로 함수를 구별할 수 없다는 단점이 있습니다. 단, 이름이 붙은 익명 함수는 어떤 함수인지 확인할 수 있습니다.
